import type { JSX } from "../jsx";
export declare function enableHydration(): void;
/**
 * A general `Component` has no implicit `children` prop.  If desired, you can
 * specify one as in `Component<{name: String, children: JSX.Element>}`.
 */
export declare type Component<P = {}> = (props: P) => JSX.Element;
/**
 * Extend props to forbid the `children` prop.
 * Use this to prevent accidentally passing `children` to components that
 * would silently throw them away.
 */
export declare type VoidProps<P = {}> = P & {
    children?: never;
};
/**
 * `VoidComponent` forbids the `children` prop.
 * Use this to prevent accidentally passing `children` to components that
 * would silently throw them away.
 */
export declare type VoidComponent<P = {}> = Component<VoidProps<P>>;
/**
 * Extend props to allow an optional `children` prop with the usual
 * type in JSX, `JSX.Element` (which allows elements, arrays, functions, etc.).
 * Use this for components that you want to accept children.
 */
export declare type ParentProps<P = {}> = P & {
    children?: JSX.Element;
};
/**
 * `ParentComponent` allows an optional `children` prop with the usual
 * type in JSX, `JSX.Element` (which allows elements, arrays, functions, etc.).
 * Use this for components that you want to accept children.
 */
export declare type ParentComponent<P = {}> = Component<ParentProps<P>>;
/**
 * Extend props to require a `children` prop with the specified type.
 * Use this for components where you need a specific child type,
 * typically a function that receives specific argument types.
 * Note that all JSX <Elements> are of the type `JSX.Element`.
 */
export declare type FlowProps<P = {}, C = JSX.Element> = P & {
    children: C;
};
/**
 * `FlowComponent` requires a `children` prop with the specified type.
 * Use this for components where you need a specific child type,
 * typically a function that receives specific argument types.
 * Note that all JSX <Elements> are of the type `JSX.Element`.
 */
export declare type FlowComponent<P = {}, C = JSX.Element> = Component<FlowProps<P, C>>;
/** @deprecated: use `ParentProps` instead */
export declare type PropsWithChildren<P = {}> = ParentProps<P>;
/**
 * Takes the props of the passed component and returns its type
 *
 * @example
 * ComponentProps<typeof Portal> // { mount?: Node; useShadow?: boolean; children: JSX.Element }
 * ComponentProps<'div'> // JSX.HTMLAttributes<HTMLDivElement>
 */
export declare type ComponentProps<T extends keyof JSX.IntrinsicElements | Component<any>> = T extends Component<infer P> ? P : T extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[T] : {};
/**
 * Type of `props.ref`, for use in `Component` or `props` typing.
 *
 * @example Component<{ref: Ref<Element>}>
 */
export declare type Ref<T> = T | ((val: T) => void);
export declare function createComponent<T>(Comp: Component<T>, props: T): JSX.Element;
declare type Override<T, U> = T extends any ? U extends any ? {
    [K in keyof T]: K extends keyof U ? undefined extends U[K] ? Exclude<U[K], undefined> | T[K] : U[K] : T[K];
} & {
    [K in keyof U]: K extends keyof T ? undefined extends U[K] ? Exclude<U[K], undefined> | T[K] : U[K] : U[K];
} : T & U : T & U;
export declare type MergeProps<T extends unknown[], Curr = {}> = T extends [
    infer Next | (() => infer Next),
    ...infer Rest
] ? MergeProps<Rest, Override<Curr, Next>> : Curr;
export declare function mergeProps<T extends [unknown, ...unknown[]]>(...sources: T): MergeProps<T>;
export declare type SplitProps<T, K extends (readonly (keyof T)[])[]> = [
    ...{
        [P in keyof K]: P extends `${number}` ? Pick<T, Extract<K[P], readonly (keyof T)[]>[number]> : never;
    },
    Omit<T, K[number][number]>
];
export declare function splitProps<T, K extends [readonly (keyof T)[], ...(readonly (keyof T)[])[]]>(props: T, ...keys: K): SplitProps<T, K>;
export declare function lazy<T extends Component<any>>(fn: () => Promise<{
    default: T;
}>): T & {
    preload: () => Promise<{
        default: T;
    }>;
};
export declare function createUniqueId(): string;
export {};
